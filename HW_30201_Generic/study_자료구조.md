# 자료구조

[MSDN](https://learn.microsoft.com/ko-kr/dotnet/standard/generics/collections)

## 앞서서

### 자료구조 개념

데이터를 용도에 따라 더 효율적으로 **저장, 읽기, 탐색, 삽입&삭제** 하기 위한 데이터 저장 기법.
프로그래머 입장에서는 일반적으로 각 동작에 따라 **평균 [시간 복잡도](#시간-복잡도)**와 **최악 시간 복잡도**를 기준으로 어떤 자료구조를 사용할지 결정하게 된다.

## [List\<T>](https://learn.microsoft.com/ko-kr/dotnet/api/system.collections.generic.list-1?view=net-8.0)

데이터를 연속된 메모리 공간에 저장하는 배열 기반 자료구조이다. 미리 예약된 공간 내에서 길이를 조절 가능한 배열처럼 작동하고, 예약된 공간 이상의 공간이 필요해지면 더 큰 공간을 새로 할당받아 전체를 복사해 이동하는 방식으로 구현되어있다.

* 마지막에 삽입 `Add()` O(1)
* 중간에 삽입 `Insert()` O(n) : 지정한 위치 이후의 데이터를 전부 한 칸씩 밀어서 새로 저장해야 한다.
* 중간에 삭제 `RemoveAt()` O(n) : 삭제한 위치 이후의 데이터를 전부 한 칸씩 당겨서 새로 저장해야 한다.
* 특정 데이터 삭제 `Remove()` O(n) : 특정 데이터 탐색 + 중간에 삭제
* 인덱스 접근 `[ ]` O(1) : 데이터가 연속되서 저장되어 있으므로 인덱스를 알면 곧바로 위치를 계산할 수 있다.
* 탐색 `IndexOf()` `Contains()` O(n) : 데이터 순서에 제약이 없는 자료구조이므로 모든 데이터를 하나씩 순회해서 탐색해야 한다.

## [LinkedList\<T>](https://learn.microsoft.com/ko-kr/dotnet/api/system.collections.generic.linkedlist-1?view=net-8.0)

노드마다 하나의 데이터와 이전 순번, 다음 순번 노드의 위치를 갖고있는 [노드](#노드node) 기반 자료구조이다. 데이터를 앞 뒤 순서에 기반해서 저장하기 때문에 선형적 자료구조이지만, 실제 메모리상에서 데이터를 연속적으로 보관하지 않았기 때문에 삽입 삭제시 재 정렬이 필요없다.

* 삽입 `AddAfter()` `AddBefore()` `AddFirst()` `AddLast()` O(1) : 위치를 이미 알고있다는 조건 아래에서, 앞 뒤 노드의 참조만 변경하므로 복잡도가 상수이다.
* 접근 : 노드간의 링크를 기반으로 한 자료구조이므로 중간의 노드에 접근하기 위해서는 노드를 하나씩 타고 넘어가야 한다. 그래서 인덱스를 통한 접근 자체를 기본적으로 지원하지 않는다.
* 탐색 `Find()` O(n) : List와 마찬가지로 데이터 순서에 제약이 없는 자료구조이므로 모든 데이터를 하나씩 순회해서 탐색해야 한다.

## [Stack\<T>](https://learn.microsoft.com/ko-kr/dotnet/api/system.collections.generic.stack-1?view=net-8.0)

List와 작동 방식이 유사한 배열 기반 자료구조이다. 가장 마지막 위치에서만 데이터를 넣고, 마지막 위치에서만 데이터를 꺼낼 수 있다. 기능을 제한함으로서 최근에 저장한 데이터부터 순차적으로 꺼낸다는 사용 목적을 명확히 한 자료구조.

## [Queue\<T>](https://learn.microsoft.com/ko-kr/dotnet/api/system.collections.generic.queue-1?view=net-8.0)

Stack과 반대로 가장 먼저 넣은 데이터만 꺼낼 수 있는 자료구조. '머리'와 '꼬리'에 헤당하는 인덱스를 데이터를 넣고 꺼낼때마다 움직여주는 방식으로 구현되어있다(C#). 손님 줄은 가만히 서있는데 직원이 움직이면서 앞에서부터 응대하는 그림.

## 기타

### 시간 복잡도

데이터의 개수(n)가 증가함에 따라 읽기, 탐색, 삽입&삭제 각각에 필요한 시간이 어떻게 변화하는지 나타낸 것. Big-O표기법을  사용한다.

* O(1)
* O(log n)
* O(n)
* O(n<sup>2</sup>)

### 노드(node)

자료를 관리하는 방법 중 하나이다. 노드마다 데이터와 다른 노드의 위치를 갖고있고, 노드간의 연결 관계를 설정해서 자료구조를 구성한다.
